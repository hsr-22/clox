# clox - A C Implementation of the Lox Language

clox is a C implementation of the Lox programming language, inspired by the book [Crafting Interpreters](https://craftinginterpreters.com/contents.html) by Robert Nystrom. This project implements a tree-walk interpreter for the Lox language, following the structure and guidelines provided in the book.

## Table of Contents
- Introduction
- Project Structure
- Building and Running
- Code Overview
  - Main Entry Point
  - Virtual Machine
  - Compiler
  - Scanner
  - Parser
  - Bytecode
  - Memory Management
  - Debugging
- References

## Introduction
Lox is a dynamically-typed, interpreted language with a syntax similar to JavaScript. This project, clox, is a bytecode interpreter for Lox written in C. It includes a scanner, parser, compiler, virtual machine, and garbage collector.

## Project Structure
The project is organized as follows:
```
.gitignore
.vscode/
    launch.json
    tasks.json
chunk.c
chunk.h
common.h
compiler.c
compiler.h
debug.c
debug.h
lox.md
main.c
main.exe
memory.c
memory.h
object.c
object.h
scanner.c
scanner.h
table.c
table.h
value.c
value.h
vm.c
vm.h
```

## Building and Running
To build and run the project, follow these steps:

1. **Build the project**:
    ```sh
    gcc -o clox main.c chunk.c compiler.c debug.c memory.c object.c scanner.c table.c value.c vm.c
    ```

2. **Run the REPL**:
    ```sh
    ./clox
    ```

3. **Run a Lox script**:
    ```sh
    ./clox path/to/script.lox
    ```

## Code Overview

### Main Entry Point
The main entry point is in 

main.c

. It initializes the virtual machine, handles command-line arguments, and starts the REPL or runs a script file.

```c
int main(int argc, const char* argv[]) {
    initVM();

    if (argc == 1) {
        repl();
    } else if (argc == 2) {
        runFile(argv[1]);
    } else {
        fprintf(stderr, "Usage: clox [path]\n");
        exit(64);
    }

    freeVM();
    return 0;
}
```

### Virtual Machine
The virtual machine is implemented in 

vm.c

 and 

vm.h

. It executes the bytecode generated by the compiler.

```c
void initVM() {
    resetStack();
    vm.objects = NULL;
    initTable(&vm.globals);
    initTable(&vm.strings);
}

InterpretResult interpret(const char* source) {
    Chunk chunk;
    initChunk(&chunk);

    if (!compile(source, &chunk)) {
        freeChunk(&chunk);
        return INTERPRET_COMPILE_ERROR;
    }

    vm.chunk = &chunk;
    vm.ip = vm.chunk->code;

    InterpretResult result = run();

    freeChunk(&chunk);
    return result;
}
```

### Compiler
The compiler translates Lox source code into bytecode. It is implemented in 

compiler.c

 and 

compiler.h

.

```c
bool compile(const char* source, Chunk* chunk) {
    initScanner(source);
    Compiler compiler;
    initCompiler(&compiler);
    compilingChunk = chunk;

    parser.hadError = false;
    parser.panicMode = false;

    advance();
    
    while (!match(TOKEN_EOF)) {
        declaration();
    }

    endCompiler();
    return !parser.hadError;
}
```

### Scanner
The scanner tokenizes the source code. It is implemented in 

scanner.c

 and 

scanner.h

.

```c
void initScanner(const char* source) {
    scanner.start = source;
    scanner.current = source;
    scanner.line = 1;
}

Token scanToken() {
    skipWhitespace();
    scanner.start = scanner.current;

    if (isAtEnd()) return makeToken(TOKEN_EOF);

    char c = advance();
    if (isAlpha(c)) return identifier();
    if (isDigit(c)) return number();

    switch (c) {
        case '(': return makeToken(TOKEN_LEFT_PAREN);
        case ')': return makeToken(TOKEN_RIGHT_PAREN);
        // ... other cases ...
    }

    return errorToken("Unexpected character.");
}
```

### Parser
The parser generates an abstract syntax tree (AST) from the tokens produced by the scanner. It is part of the compiler in 

compiler.c

.

### Bytecode
The bytecode representation of the Lox program is managed by the 

Chunk

 structure in 

chunk.c

 and 

chunk.h

.

```c
void writeChunk(Chunk* chunk, uint8_t byte, int line) {
    if (chunk->capacity < chunk->count + 1) {
        int oldCapacity = chunk->capacity;
        chunk->capacity = GROW_CAPACITY(oldCapacity);
        chunk->code = GROW_ARRAY(uint8_t, chunk->code, oldCapacity, chunk->capacity);
        chunk->lines = GROW_ARRAY(int, chunk->lines, oldCapacity, chunk->capacity);
    }

    chunk->code[chunk->count] = byte;
    chunk->lines[chunk->count] = line;
    chunk->count++;
}
```

### Memory Management
Memory management, including garbage collection, is handled in 

memory.c

 and 

memory.h

.

```c
void* reallocate(void* pointer, size_t oldSize, size_t newSize) {
    if (newSize == 0) {
        free(pointer);
        return NULL;
    }

    void* result = realloc(pointer, newSize);
    if (result == NULL) exit(1);
    return result;
}

void freeObjects() {
    Obj* object = vm.objects;
    while (object != NULL) {
        Obj* next = object->next;
        freeObject(object);
        object = next;
    }
}
```

### Debugging
Debugging utilities are provided in 

debug.c

 and 

debug.h

. These include functions to disassemble bytecode and print the contents of the stack.

```c
void disassembleChunk(Chunk* chunk, const char* name) {
    printf("== %s ==\n", name);

    for (int offset = 0; offset < chunk->count;) {
        offset = disassembleInstruction(chunk, offset);
    }
}
```

## References
- [Crafting Interpreters](https://craftinginterpreters.com/contents.html) by Robert Nystrom

This README provides an overview of the clox project, its structure, and the main components involved in interpreting the Lox language. For more detailed information, refer to the code and the [Crafting Interpreters](https://craftinginterpreters.com/contents.html) book.